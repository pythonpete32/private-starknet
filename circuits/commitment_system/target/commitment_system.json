{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":13957212201663075385,"abi":{"parameters":[{"name":"merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_alice","type":{"kind":"field"},"visibility":"public"},{"name":"commitment_alice_new","type":{"kind":"field"},"visibility":"public"},{"name":"commitment_bob_new","type":{"kind":"field"},"visibility":"public"},{"name":"asset_id","type":{"kind":"field"},"visibility":"public"},{"name":"value_alice_old","type":{"kind":"field"},"visibility":"private"},{"name":"value_alice_new","type":{"kind":"field"},"visibility":"private"},{"name":"value_bob_received","type":{"kind":"field"},"visibility":"private"},{"name":"nonce_alice_old","type":{"kind":"field"},"visibility":"private"},{"name":"nonce_alice_new","type":{"kind":"field"},"visibility":"private"},{"name":"alice_secret_key","type":{"kind":"field"},"visibility":"private"},{"name":"alice_old_commitment_id","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_path","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"merkle_indices","type":{"kind":"array","length":20,"type":{"kind":"boolean"}},"visibility":"private"}],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"61":{"source":"use std::hash::pedersen_hash;\n\n// COMMITMENT STRUCTURE\n// Think of this like a \"private balance record\"\n// It contains:\n// - hash: The public identifier (what everyone sees on-chain)\n// - value: The actual balance (kept secret)\n// - nonce: Random number to hide the balance (kept secret)\nstruct Commitment {\n    hash: Field,\n    value: Field,\n    nonce: Field,\n    asset_id: Field,\n}\n\nimpl Commitment {\n    // Creates a new commitment\n    // This is like creating a \"sealed envelope\" with your balance inside\n    fn new(value: Field, nonce: Field, asset_id: Field) -> Self {\n        Self {\n            // The hash is what gets published on-chain\n            // Nobody can reverse this to find your balance!\n            hash: pedersen_hash([value, nonce, asset_id]),\n            value,\n            nonce,\n            asset_id,\n        }\n    }\n    \n    // Verify that the commitment data matches the hash\n    // This proves you know the secret values inside the commitment\n    fn verify(self) -> bool {\n        self.hash == pedersen_hash([self.value, self.nonce, self.asset_id])\n    }\n}\n\n// NULLIFIER STRUCTURE\n// Think of this like a \"burn receipt\" or \"spend proof\"\n// Once a nullifier is used, that commitment can never be spent again\nstruct Nullifier {\n    hash: Field,\n    secret_key: Field,\n    commitment_id: Field,  // Changed from asset_id for clarity\n}\n\nimpl Nullifier {\n    // Creates a nullifier for spending a commitment\n    // Only the owner (who knows secret_key) can create this\n    fn new(secret_key: Field, commitment_id: Field) -> Self {\n        Self {\n            // This hash is what prevents double-spending\n            // Same commitment always produces same nullifier\n            hash: pedersen_hash([secret_key, commitment_id]),\n            secret_key,\n            commitment_id,\n        }\n    }\n    \n    // Verify the nullifier is correctly formed\n    fn verify(self) -> bool {\n        self.hash == pedersen_hash([self.secret_key, self.commitment_id])\n    }\n}\n\n// MERKLE TREE VERIFICATION\n// Proves that a commitment exists in the global state tree\nfn verify_merkle_proof(\n    commitment: Field,\n    merkle_root: Field,\n    merkle_path: [Field; 20],\n    merkle_indices: [bool; 20]\n) -> bool {\n    let mut current_hash = commitment;\n    \n    // Walk up the tree from leaf to root\n    for i in 0..20 {\n        let sibling = merkle_path[i];\n        let is_left = merkle_indices[i];\n        \n        // Skip if sibling is zero (indicates empty path)\n        if sibling != 0 {\n            if is_left {\n                // Current node is left child\n                current_hash = pedersen_hash([current_hash, sibling]);\n            } else {\n                // Current node is right child\n                current_hash = pedersen_hash([sibling, current_hash]);\n            }\n        }\n    }\n    \n    current_hash == merkle_root\n}\n\n// MAIN TRANSFER CIRCUIT\n// This is the core logic that gets turned into a zero-knowledge proof\n// Think of it like the rules that MUST be satisfied for a valid transfer\nfn main(\n    // ===== PUBLIC INPUTS =====\n    // These are visible to everyone on-chain\n    \n    // Current Merkle tree root (proves global state)\n    merkle_root: pub Field,\n    \n    // The nullifier that \"burns\" Alice's old balance\n    // This prevents Alice from spending the same balance twice\n    nullifier_alice: pub Field,\n    \n    // Alice's new commitment (her remaining balance after transfer)\n    commitment_alice_new: pub Field,\n    \n    // Bob's new commitment (the amount he receives) - PROVIDED BY BOB\n    commitment_bob_new: pub Field,\n    \n    // The token type being transferred (like USDC address in Solidity)\n    asset_id: pub Field,\n    \n    // ===== PRIVATE INPUTS =====\n    // These stay secret! Only the prover (Alice) knows these\n    \n    // Alice's old balance (before transfer)\n    value_alice_old: Field,\n    \n    // Alice's new balance (after transfer)\n    value_alice_new: Field,\n    \n    // Bob's received amount (Alice knows this but NOT Bob's nonce)\n    value_bob_received: Field,\n    \n    // Random values to hide the balances\n    nonce_alice_old: Field,\n    nonce_alice_new: Field,\n    // NOTE: nonce_bob removed - Bob keeps this secret!\n    \n    // Alice's secret key (like a private key)\n    // This proves Alice owns the commitment she's spending\n    alice_secret_key: Field,\n    \n    // The ID of Alice's old commitment (what she's spending)\n    alice_old_commitment_id: Field,\n    \n    // Merkle proof that Alice's old commitment exists in the tree\n    merkle_path: [Field; 20],\n    merkle_indices: [bool; 20],\n) {\n    // ===== CONSTRAINT 1: Verify Alice's commitment exists in global state =====\n    // Create Alice's old commitment from her secrets\n    let alice_old_commitment = Commitment::new(value_alice_old, nonce_alice_old, asset_id);\n    assert(alice_old_commitment.verify());\n    \n    // Prove this commitment exists in the Merkle tree\n    // This prevents Alice from claiming fake balances!\n    assert(verify_merkle_proof(\n        alice_old_commitment.hash,\n        merkle_root,\n        merkle_path,\n        merkle_indices\n    ));\n    \n    // ===== CONSTRAINT 2: Verify Alice owns what she's spending =====\n    // Create the nullifier using Alice's secret\n    let nullifier = Nullifier::new(alice_secret_key, alice_old_commitment_id);\n    \n    // The nullifier hash MUST match what was provided publicly\n    // This proves Alice knows the secret key for this commitment\n    assert(nullifier_alice == nullifier.hash);\n    assert(nullifier.verify());\n    \n    // ===== CONSTRAINT 3: Verify Alice's new balance commitment =====\n    // Create Alice's new commitment\n    let alice_new_commitment = Commitment::new(value_alice_new, nonce_alice_new, asset_id);\n    \n    // Must match the public commitment\n    // This ensures Alice can later spend her new balance\n    assert(commitment_alice_new == alice_new_commitment.hash);\n    assert(alice_new_commitment.verify());\n    \n    // ===== CONSTRAINT 4: Bob's commitment is provided by Bob =====\n    // Bob creates his own commitment with his own secret nonce\n    // Alice cannot create or verify Bob's commitment - she only knows the amount\n    // This prevents Alice from later spending Bob's tokens\n    // \n    // NOTE: commitment_bob_new is intentionally not verified here by design!\n    // It's provided as a public input but Alice's circuit doesn't verify it.\n    // Bob will verify his own commitment when he later spends it.\n    // We acknowledge its existence to satisfy the compiler:\n    let _ = commitment_bob_new;\n    \n    // ===== CONSTRAINT 5: Conservation of value (NO TOKENS CREATED/DESTROYED) =====\n    // This is CRITICAL! Ensures no inflation/deflation\n    // Old balance MUST equal new balance + transferred amount\n    assert(value_alice_old == value_alice_new + value_bob_received);\n    \n    // NOTE: Alice's old commitment verification moved to CONSTRAINT 1\n    // (Combined with Merkle tree verification)\n    \n    // ===== CONSTRAINT 6: Reasonable value checks =====\n    // Prevent overflow attacks and ensure positive balances\n    assert(value_alice_old as u32 < 1000000);\n    assert(value_alice_new as u32 < 1000000);\n    assert(value_bob_received as u32 < 1000000);\n    \n    // No negative balances allowed!\n    assert(value_bob_received as u32 > 0);\n    \n    // ===== CONSTRAINT 7: Asset consistency =====\n    // Ensure we're transferring the same asset type throughout\n    // This prevents mixing different tokens in a single transfer\n    assert(alice_new_commitment.asset_id == asset_id);\n    assert(alice_old_commitment.asset_id == asset_id);\n    // Note: Bob's commitment asset_id is verified by Bob when he creates it\n}\n\n// ===== TEST FUNCTIONS =====\n\n#[test]\nfn test_commitment_basics() {\n    // Test that commitments work as expected\n    let value = 100;\n    let nonce = 12345;\n    \n    // Create a commitment\n    let asset_id = 1; // Test asset\n    let commitment1 = Commitment::new(value, nonce, asset_id);\n    \n    // Same inputs should always produce same hash (deterministic)\n    let commitment2 = Commitment::new(value, nonce, asset_id);\n    assert(commitment1.hash == commitment2.hash);\n    \n    // Different nonce should produce different hash\n    let commitment3 = Commitment::new(value, 54321, asset_id);\n    assert(commitment1.hash != commitment3.hash);\n    \n    // Commitment should verify correctly\n    assert(commitment1.verify());\n}\n\n#[test]\nfn test_nullifier_basics() {\n    // Test nullifier generation\n    let secret_key = 99999;\n    let commitment_id = 42;\n    \n    // Create nullifier\n    let nullifier1 = Nullifier::new(secret_key, commitment_id);\n    \n    // Same inputs produce same nullifier (prevents double-spend)\n    let nullifier2 = Nullifier::new(secret_key, commitment_id);\n    assert(nullifier1.hash == nullifier2.hash);\n    \n    // Different secret produces different nullifier\n    let nullifier3 = Nullifier::new(11111, commitment_id);\n    assert(nullifier1.hash != nullifier3.hash);\n    \n    // Nullifier should verify\n    assert(nullifier1.verify());\n}\n\n#[test]\nfn test_merkle_verification() {\n    // Test the Merkle tree verification function\n    let test_commitment = 0x1234567890ABCDEF;\n    \n    // Test case 1: Single node tree (commitment is root)\n    let merkle_root = test_commitment;\n    let merkle_path: [Field; 20] = [0; 20]; // All zeros for single node\n    let merkle_indices: [bool; 20] = [false; 20]; // All false for root\n    \n    // Should verify successfully\n    assert(verify_merkle_proof(test_commitment, merkle_root, merkle_path, merkle_indices));\n    \n    // Test case 2: Wrong commitment should fail\n    let wrong_commitment = 0xDEADBEEF;\n    assert(!verify_merkle_proof(wrong_commitment, merkle_root, merkle_path, merkle_indices));\n}\n\n#[test]\nfn test_complete_private_transfer() {\n    // ===== SETUP: Alice has 100 tokens, wants to send 30 to Bob =====\n    \n    // Initial state\n    let value_alice_old = 100;  // Alice starts with 100\n    let value_alice_new = 70;   // Alice will have 70 after\n    let value_bob_received = 30; // Bob receives 30\n    \n    // Random nonces (in practice, these would be generated securely)\n    let nonce_alice_old = 111111;\n    let nonce_alice_new = 222222;\n    let nonce_bob = 333333;  // BOB GENERATES THIS SECRETLY\n    \n    // Alice's secret key (like her private key)\n    let alice_secret_key = 0xABCDEF;\n    \n    // Asset being transferred (could be USDC address)\n    let asset_id = 0x1234567890;\n    \n    // Alice's old commitment ID (in practice, this would be from the blockchain)\n    let alice_old_commitment_id = 0x9876543210;\n    \n    // ===== MERKLE TREE SETUP =====\n    // Create Alice's old commitment\n    let alice_old_commitment = Commitment::new(value_alice_old, nonce_alice_old, asset_id);\n    \n    // Create a simple test Merkle tree with Alice's commitment at index 0\n    // For simplicity, we'll create a minimal tree with Alice's commitment as the root\n    let merkle_root = alice_old_commitment.hash; // Simplified: commitment is the root\n    let merkle_path: [Field; 20] = [0; 20]; // All zeros for a single-node tree\n    let merkle_indices: [bool; 20] = [false; 20]; // All false for root verification\n    \n    // ===== INTERACTIVE PROTOCOL =====\n    // 1. Alice tells Bob she wants to send him 30 tokens\n    // 2. Bob creates his own commitment with his secret nonce\n    // 3. Bob sends commitment hash to Alice (keeps nonce secret!)\n    // 4. Alice creates proof using Bob's commitment hash\n    \n    // BOB'S SIDE: Create commitment with secret nonce\n    let bob_commitment = Commitment::new(value_bob_received, nonce_bob, asset_id);\n    // Bob sends bob_commitment.hash to Alice, keeps nonce_bob secret\n    \n    // ALICE'S SIDE: Create her new commitment\n    let alice_new_commitment = Commitment::new(value_alice_new, nonce_alice_new, asset_id);\n    \n    // Create the nullifier (burns Alice's old balance)\n    let nullifier = Nullifier::new(alice_secret_key, alice_old_commitment_id);\n    \n    // ===== RUN THE TRANSFER (generate the proof) =====\n    // Alice can prove the transfer with Merkle verification!\n    main(\n        merkle_root,                // Public: Current tree state\n        nullifier.hash,            // Public: Nullifier for Alice's old balance\n        alice_new_commitment.hash,  // Public: Alice's new balance commitment\n        bob_commitment.hash,        // Public: Bob's commitment (provided by Bob)\n        asset_id,                  // Public: Which token is being transferred\n        value_alice_old,           // Private: Alice's old balance\n        value_alice_new,           // Private: Alice's new balance\n        value_bob_received,        // Private: Bob's received amount (known to both)\n        nonce_alice_old,          // Private: Old nonce\n        nonce_alice_new,          // Private: New nonce for Alice\n        alice_secret_key,         // Private: Alice's secret\n        alice_old_commitment_id,   // Private: Which commitment Alice is spending\n        merkle_path,              // Private: Merkle proof path\n        merkle_indices            // Private: Merkle proof directions\n        // NOTE: nonce_bob is NOT provided to Alice - Bob keeps it secret!\n    );\n}\n\n#[test(should_fail)]\nfn test_invalid_transfer_conservation() {\n    // This test SHOULD FAIL because it tries to create tokens out of thin air\n    // 80 + 30 = 110, but Alice only had 100!\n    \n    let value_alice_old = 100;\n    let value_alice_new = 80;    // Alice keeps 80\n    let value_bob_received = 30;  // Bob gets 30\n    \n    let nonce_alice_old = 111;\n    let nonce_alice_new = 222;\n    let nonce_bob = 333;  // Bob's secret nonce\n    let alice_secret_key = 12345;\n    let asset_id = 1;\n    let alice_old_commitment_id = 999;\n    \n    // Setup Merkle tree with Alice's commitment\n    let alice_old_commitment = Commitment::new(value_alice_old, nonce_alice_old, asset_id);\n    let merkle_root = alice_old_commitment.hash;\n    let merkle_path: [Field; 20] = [0; 20];\n    let merkle_indices: [bool; 20] = [false; 20];\n    \n    let alice_new_commitment = Commitment::new(value_alice_new, nonce_alice_new, asset_id);\n    let bob_commitment = Commitment::new(value_bob_received, nonce_bob, asset_id);\n    let nullifier = Nullifier::new(alice_secret_key, alice_old_commitment_id);\n    \n    // This will fail the conservation check: value_alice_old != value_alice_new + value_bob_received\n    main(\n        merkle_root,               // Public: Tree root\n        nullifier.hash,           // Public: Nullifier\n        alice_new_commitment.hash, // Public: Alice's new commitment\n        bob_commitment.hash,       // Public: Bob's commitment\n        asset_id,                 // Public: Asset ID\n        value_alice_old,          // Private: Alice's old balance\n        value_alice_new,          // Private: Alice's new balance (wrong!)\n        value_bob_received,       // Private: Transfer amount\n        nonce_alice_old,         // Private: Old nonce\n        nonce_alice_new,         // Private: New nonce\n        alice_secret_key,        // Private: Secret key\n        alice_old_commitment_id, // Private: Commitment ID\n        merkle_path,             // Private: Merkle path\n        merkle_indices           // Private: Merkle indices\n    );\n}\n\n#[test(should_fail)]\nfn test_zero_value_transfer() {\n    // This test SHOULD FAIL because we require positive transfer amounts\n    \n    let value_alice_old = 100;\n    let value_alice_new = 100;   // Alice keeps everything\n    let value_bob_received = 0;   // Bob gets nothing - this should fail\n    \n    let nonce_alice_old = 111;\n    let nonce_alice_new = 222;\n    let nonce_bob = 333;  // Bob's secret nonce\n    let alice_secret_key = 12345;\n    let asset_id = 1;\n    let alice_old_commitment_id = 999;\n    \n    // Setup Merkle tree with Alice's commitment\n    let alice_old_commitment = Commitment::new(value_alice_old, nonce_alice_old, asset_id);\n    let merkle_root = alice_old_commitment.hash;\n    let merkle_path: [Field; 20] = [0; 20];\n    let merkle_indices: [bool; 20] = [false; 20];\n    \n    let alice_new_commitment = Commitment::new(value_alice_new, nonce_alice_new, asset_id);\n    let bob_commitment = Commitment::new(value_bob_received, nonce_bob, asset_id);\n    let nullifier = Nullifier::new(alice_secret_key, alice_old_commitment_id);\n    \n    // This will fail the positive value check: assert(value_bob_received as u32 > 0)\n    main(\n        merkle_root,               // Public: Tree root\n        nullifier.hash,           // Public: Nullifier\n        alice_new_commitment.hash, // Public: Alice's new commitment\n        bob_commitment.hash,       // Public: Bob's commitment\n        asset_id,                 // Public: Asset ID\n        value_alice_old,          // Private: Alice's old balance\n        value_alice_new,          // Private: Alice's new balance\n        value_bob_received,       // Private: Transfer amount (0 - should fail!)\n        nonce_alice_old,         // Private: Old nonce\n        nonce_alice_new,         // Private: New nonce\n        alice_secret_key,        // Private: Secret key\n        alice_old_commitment_id, // Private: Commitment ID\n        merkle_path,             // Private: Merkle path\n        merkle_indices           // Private: Merkle indices\n    );\n}\n\n// ===== ABOUT THE PRIVATE COMMUNICATION PROBLEM - SOLVED! =====\n// \n// Problem: \"How does Alice send to Bob privately? Can't she spend his funds?\"\n// \n// SOLUTION IMPLEMENTED: Interactive Transfer Protocol\n//\n// 1. Alice tells Bob she wants to send him tokens\n// 2. Bob generates his own secret nonce\n// 3. Bob creates commitment = hash(amount, bob_secret_nonce, asset_id)\n// 4. Bob sends commitment hash to Alice (keeps nonce secret!)\n// 5. Alice creates ZK proof using Bob's commitment hash\n// 6. Alice publishes proof and Bob's commitment on-chain\n// 7. Bob can later spend using his secret nonce\n// 8. Alice CANNOT spend Bob's tokens because she doesn't know bob_secret_nonce!\n//\n// This circuit implements step 5: Alice proves she can transfer the amount\n// without needing to know Bob's secrets.\n//\n// Other solutions for non-interactive transfers:\n// - Stealth addresses (Bob's public key generates unique commitments)\n// - Encrypted notes (Alice encrypts details for Bob)\n// - Commitment derivation schemes (mathematical relationships)\n//\n// The interactive approach is the simplest and most secure for this use case.","path":"/Users/abuusama/Desktop/private-starknet/circuits/commitment_system/src/main.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_invert","directive_integer_quotient"]}