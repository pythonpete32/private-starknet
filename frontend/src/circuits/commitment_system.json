{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"8875118019841176054","abi":{"parameters":[{"name":"merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_alice","type":{"kind":"field"},"visibility":"public"},{"name":"commitment_alice_new","type":{"kind":"field"},"visibility":"public"},{"name":"commitment_bob_new","type":{"kind":"field"},"visibility":"public"},{"name":"asset_id","type":{"kind":"field"},"visibility":"public"},{"name":"value_alice_old","type":{"kind":"field"},"visibility":"private"},{"name":"value_alice_new","type":{"kind":"field"},"visibility":"private"},{"name":"value_bob_received","type":{"kind":"field"},"visibility":"private"},{"name":"nonce_alice_old","type":{"kind":"field"},"visibility":"private"},{"name":"nonce_alice_new","type":{"kind":"field"},"visibility":"private"},{"name":"alice_secret_key","type":{"kind":"field"},"visibility":"private"},{"name":"alice_old_commitment_id","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_path","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"merkle_indices","type":{"kind":"array","length":20,"type":{"kind":"boolean"}},"visibility":"private"}],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"use std::hash::pedersen_hash;\n\n// COMMITMENT STRUCTURE\n// Think of this like a \"private balance record\"\n// It contains:\n// - hash: The public identifier (what everyone sees on-chain)\n// - value: The actual balance (kept secret)\n// - nonce: Random number to hide the balance (kept secret)\nstruct Commitment {\n    hash: Field,\n    value: Field,\n    nonce: Field,\n    asset_id: Field,\n}\n\nimpl Commitment {\n    // Creates a new commitment\n    // This is like creating a \"sealed envelope\" with your balance inside\n    fn new(value: Field, nonce: Field, asset_id: Field) -> Self {\n        Self {\n            // The hash is what gets published on-chain\n            // Nobody can reverse this to find your balance!\n            hash: pedersen_hash([value, nonce, asset_id]),\n            value,\n            nonce,\n            asset_id,\n        }\n    }\n\n    // Verify that the commitment data matches the hash\n    // This proves you know the secret values inside the commitment\n    fn verify(self) -> bool {\n        self.hash == pedersen_hash([self.value, self.nonce, self.asset_id])\n    }\n}\n\n// NULLIFIER STRUCTURE\n// Think of this like a \"burn receipt\" or \"spend proof\"\n// Once a nullifier is used, that commitment can never be spent again\nstruct Nullifier {\n    hash: Field,\n    secret_key: Field,\n    commitment_id: Field, // Changed from asset_id for clarity\n}\n\nimpl Nullifier {\n    // Creates a nullifier for spending a commitment\n    // Only the owner (who knows secret_key) can create this\n    fn new(secret_key: Field, commitment_id: Field) -> Self {\n        Self {\n            // This hash is what prevents double-spending\n            // Same commitment always produces same nullifier\n            hash: pedersen_hash([secret_key, commitment_id]),\n            secret_key,\n            commitment_id,\n        }\n    }\n\n    // Verify the nullifier is correctly formed\n    fn verify(self) -> bool {\n        self.hash == pedersen_hash([self.secret_key, self.commitment_id])\n    }\n}\n\n// MERKLE TREE VERIFICATION\n// Proves that a commitment exists in the global state tree\nfn verify_merkle_proof(\n    commitment: Field,\n    merkle_root: Field,\n    merkle_path: [Field; 20],\n    merkle_indices: [bool; 20],\n) -> bool {\n    let mut current_hash = commitment;\n\n    // Walk up the tree from leaf to root\n    for i in 0..20 {\n        let sibling = merkle_path[i];\n        let is_left = merkle_indices[i];\n\n        // Skip if sibling is zero (indicates empty path)\n        if sibling != 0 {\n            if is_left {\n                // Current node is left child\n                current_hash = pedersen_hash([current_hash, sibling]);\n            } else {\n                // Current node is right child\n                current_hash = pedersen_hash([sibling, current_hash]);\n            }\n        }\n    }\n\n    current_hash == merkle_root\n}\n\n// MAIN TRANSFER CIRCUIT\n// This is the core logic that gets turned into a zero-knowledge proof\n// Think of it like the rules that MUST be satisfied for a valid transfer\nfn main(\n    // ===== PUBLIC INPUTS =====\n    // These are visible to everyone on-chain\n    // Current Merkle tree root (proves global state)\n    merkle_root: pub Field,\n    // The nullifier that \"burns\" Alice's old balance\n    // This prevents Alice from spending the same balance twice\n    nullifier_alice: pub Field,\n    // Alice's new commitment (her remaining balance after transfer)\n    commitment_alice_new: pub Field,\n    // Bob's new commitment (the amount he receives) - PROVIDED BY BOB\n    commitment_bob_new: pub Field,\n    // The token type being transferred (like USDC address in Solidity)\n    asset_id: pub Field,\n    // ===== PRIVATE INPUTS =====\n    // These stay secret! Only the prover (Alice) knows these\n    // Alice's old balance (before transfer)\n    value_alice_old: Field,\n    // Alice's new balance (after transfer)\n    value_alice_new: Field,\n    // Bob's received amount (Alice knows this but NOT Bob's nonce)\n    value_bob_received: Field,\n    // Random values to hide the balances\n    nonce_alice_old: Field,\n    nonce_alice_new: Field,\n    // NOTE: nonce_bob removed - Bob keeps this secret!\n    // Alice's secret key (like a private key)\n    // This proves Alice owns the commitment she's spending\n    alice_secret_key: Field,\n    // The ID of Alice's old commitment (what she's spending)\n    alice_old_commitment_id: Field,\n    // Merkle proof that Alice's old commitment exists in the tree\n    merkle_path: [Field; 20],\n    merkle_indices: [bool; 20],\n) {\n    // ===== CONSTRAINT 1: Verify Alice's commitment exists in global state =====\n    // Create Alice's old commitment from her secrets\n    let alice_old_commitment = Commitment::new(value_alice_old, nonce_alice_old, asset_id);\n    assert(alice_old_commitment.verify());\n\n    // Prove this commitment exists in the Merkle tree\n    // This prevents Alice from claiming fake balances!\n    assert(verify_merkle_proof(\n        alice_old_commitment.hash,\n        merkle_root,\n        merkle_path,\n        merkle_indices,\n    ));\n\n    // ===== CONSTRAINT 2: Verify Alice owns what she's spending =====\n    // Create the nullifier using Alice's secret\n    let nullifier = Nullifier::new(alice_secret_key, alice_old_commitment_id);\n\n    // The nullifier hash MUST match what was provided publicly\n    // This proves Alice knows the secret key for this commitment\n    assert(nullifier_alice == nullifier.hash);\n    assert(nullifier.verify());\n\n    // ===== CONSTRAINT 3: Verify Alice's new balance commitment =====\n    // Create Alice's new commitment\n    let alice_new_commitment = Commitment::new(value_alice_new, nonce_alice_new, asset_id);\n\n    // Must match the public commitment\n    // This ensures Alice can later spend her new balance\n    assert(commitment_alice_new == alice_new_commitment.hash);\n    assert(alice_new_commitment.verify());\n\n    // ===== CONSTRAINT 4: Bob's commitment is provided by Bob =====\n    // Bob creates his own commitment with his own secret nonce\n    // Alice cannot create or verify Bob's commitment - she only knows the amount\n    // This prevents Alice from later spending Bob's tokens\n    //\n    // NOTE: commitment_bob_new is intentionally not verified here by design!\n    // It's provided as a public input but Alice's circuit doesn't verify it.\n    // Bob will verify his own commitment when he later spends it.\n    // We acknowledge its existence to satisfy the compiler:\n    let _ = commitment_bob_new;\n\n    // ===== CONSTRAINT 5: Conservation of value (NO TOKENS CREATED/DESTROYED) =====\n    // This is CRITICAL! Ensures no inflation/deflation\n    // Old balance MUST equal new balance + transferred amount\n    assert(value_alice_old == value_alice_new + value_bob_received);\n\n    // NOTE: Alice's old commitment verification moved to CONSTRAINT 1\n    // (Combined with Merkle tree verification)\n\n    // ===== CONSTRAINT 6: Reasonable value checks =====\n    // Prevent overflow attacks and ensure positive balances\n    assert(value_alice_old as u32 < 1000000);\n    assert(value_alice_new as u32 < 1000000);\n    assert(value_bob_received as u32 < 1000000);\n\n    // No negative balances allowed!\n    assert(value_bob_received as u32 > 0);\n\n    // ===== CONSTRAINT 7: Asset consistency =====\n    // Ensure we're transferring the same asset type throughout\n    // This prevents mixing different tokens in a single transfer\n    assert(alice_new_commitment.asset_id == asset_id);\n    assert(alice_old_commitment.asset_id == asset_id);\n    // Note: Bob's commitment asset_id is verified by Bob when he creates it\n}\n\n// ===== TEST FUNCTIONS =====\n\n#[test]\nfn test_commitment_basics() {\n    // Test that commitments work as expected\n    let value = 100;\n    let nonce = 12345;\n\n    // Create a commitment\n    let asset_id = 1; // Test asset\n    let commitment1 = Commitment::new(value, nonce, asset_id);\n\n    // Same inputs should always produce same hash (deterministic)\n    let commitment2 = Commitment::new(value, nonce, asset_id);\n    assert(commitment1.hash == commitment2.hash);\n\n    // Different nonce should produce different hash\n    let commitment3 = Commitment::new(value, 54321, asset_id);\n    assert(commitment1.hash != commitment3.hash);\n\n    // Commitment should verify correctly\n    assert(commitment1.verify());\n}\n\n#[test]\nfn test_nullifier_basics() {\n    // Test nullifier generation\n    let secret_key = 99999;\n    let commitment_id = 42;\n\n    // Create nullifier\n    let nullifier1 = Nullifier::new(secret_key, commitment_id);\n\n    // Same inputs produce same nullifier (prevents double-spend)\n    let nullifier2 = Nullifier::new(secret_key, commitment_id);\n    assert(nullifier1.hash == nullifier2.hash);\n\n    // Different secret produces different nullifier\n    let nullifier3 = Nullifier::new(11111, commitment_id);\n    assert(nullifier1.hash != nullifier3.hash);\n\n    // Nullifier should verify\n    assert(nullifier1.verify());\n}\n\n#[test]\nfn test_merkle_verification() {\n    // Test the Merkle tree verification function\n    let test_commitment = 0x1234567890ABCDEF;\n\n    // Test case 1: Single node tree (commitment is root)\n    let merkle_root = test_commitment;\n    let merkle_path: [Field; 20] = [0; 20]; // All zeros for single node\n    let merkle_indices: [bool; 20] = [false; 20]; // All false for root\n\n    // Should verify successfully\n    assert(verify_merkle_proof(test_commitment, merkle_root, merkle_path, merkle_indices));\n\n    // Test case 2: Wrong commitment should fail\n    let wrong_commitment = 0xDEADBEEF;\n    assert(!verify_merkle_proof(wrong_commitment, merkle_root, merkle_path, merkle_indices));\n}\n\n#[test]\nfn test_complete_private_transfer() {\n    // ===== SETUP: Alice has 100 tokens, wants to send 30 to Bob =====\n\n    // Initial state\n    let value_alice_old = 100; // Alice starts with 100\n    let value_alice_new = 70; // Alice will have 70 after\n    let value_bob_received = 30; // Bob receives 30\n\n    // Random nonces (in practice, these would be generated securely)\n    let nonce_alice_old = 111111;\n    let nonce_alice_new = 222222;\n    let nonce_bob = 333333; // BOB GENERATES THIS SECRETLY\n\n    // Alice's secret key (like her private key)\n    let alice_secret_key = 0xABCDEF;\n\n    // Asset being transferred (could be USDC address)\n    let asset_id = 0x1234567890;\n\n    // Alice's old commitment ID (in practice, this would be from the blockchain)\n    let alice_old_commitment_id = 0x9876543210;\n\n    // ===== MERKLE TREE SETUP =====\n    // Create Alice's old commitment\n    let alice_old_commitment = Commitment::new(value_alice_old, nonce_alice_old, asset_id);\n\n    // Create a simple test Merkle tree with Alice's commitment at index 0\n    // For simplicity, we'll create a minimal tree with Alice's commitment as the root\n    let merkle_root = alice_old_commitment.hash; // Simplified: commitment is the root\n    let merkle_path: [Field; 20] = [0; 20]; // All zeros for a single-node tree\n    let merkle_indices: [bool; 20] = [false; 20]; // All false for root verification\n\n    // ===== INTERACTIVE PROTOCOL =====\n    // 1. Alice tells Bob she wants to send him 30 tokens\n    // 2. Bob creates his own commitment with his secret nonce\n    // 3. Bob sends commitment hash to Alice (keeps nonce secret!)\n    // 4. Alice creates proof using Bob's commitment hash\n\n    // BOB'S SIDE: Create commitment with secret nonce\n    let bob_commitment = Commitment::new(value_bob_received, nonce_bob, asset_id);\n    // Bob sends bob_commitment.hash to Alice, keeps nonce_bob secret\n\n    // ALICE'S SIDE: Create her new commitment\n    let alice_new_commitment = Commitment::new(value_alice_new, nonce_alice_new, asset_id);\n\n    // Create the nullifier (burns Alice's old balance)\n    let nullifier = Nullifier::new(alice_secret_key, alice_old_commitment_id);\n\n    // ===== RUN THE TRANSFER (generate the proof) =====\n    // Alice can prove the transfer with Merkle verification!\n    main(\n        merkle_root, // Public: Current tree state\n        nullifier.hash, // Public: Nullifier for Alice's old balance\n        alice_new_commitment.hash, // Public: Alice's new balance commitment\n        bob_commitment.hash, // Public: Bob's commitment (provided by Bob)\n        asset_id, // Public: Which token is being transferred\n        value_alice_old, // Private: Alice's old balance\n        value_alice_new, // Private: Alice's new balance\n        value_bob_received, // Private: Bob's received amount (known to both)\n        nonce_alice_old, // Private: Old nonce\n        nonce_alice_new, // Private: New nonce for Alice\n        alice_secret_key, // Private: Alice's secret\n        alice_old_commitment_id, // Private: Which commitment Alice is spending\n        merkle_path, // Private: Merkle proof path\n        merkle_indices, // Private: Merkle proof directions\n        // NOTE: nonce_bob is NOT provided to Alice - Bob keeps it secret!\n    );\n}\n\n#[test(should_fail)]\nfn test_invalid_transfer_conservation() {\n    // This test SHOULD FAIL because it tries to create tokens out of thin air\n    // 80 + 30 = 110, but Alice only had 100!\n\n    let value_alice_old = 100;\n    let value_alice_new = 80; // Alice keeps 80\n    let value_bob_received = 30; // Bob gets 30\n\n    let nonce_alice_old = 111;\n    let nonce_alice_new = 222;\n    let nonce_bob = 333; // Bob's secret nonce\n    let alice_secret_key = 12345;\n    let asset_id = 1;\n    let alice_old_commitment_id = 999;\n\n    // Setup Merkle tree with Alice's commitment\n    let alice_old_commitment = Commitment::new(value_alice_old, nonce_alice_old, asset_id);\n    let merkle_root = alice_old_commitment.hash;\n    let merkle_path: [Field; 20] = [0; 20];\n    let merkle_indices: [bool; 20] = [false; 20];\n\n    let alice_new_commitment = Commitment::new(value_alice_new, nonce_alice_new, asset_id);\n    let bob_commitment = Commitment::new(value_bob_received, nonce_bob, asset_id);\n    let nullifier = Nullifier::new(alice_secret_key, alice_old_commitment_id);\n\n    // This will fail the conservation check: value_alice_old != value_alice_new + value_bob_received\n    main(\n        merkle_root, // Public: Tree root\n        nullifier.hash, // Public: Nullifier\n        alice_new_commitment.hash, // Public: Alice's new commitment\n        bob_commitment.hash, // Public: Bob's commitment\n        asset_id, // Public: Asset ID\n        value_alice_old, // Private: Alice's old balance\n        value_alice_new, // Private: Alice's new balance (wrong!)\n        value_bob_received, // Private: Transfer amount\n        nonce_alice_old, // Private: Old nonce\n        nonce_alice_new, // Private: New nonce\n        alice_secret_key, // Private: Secret key\n        alice_old_commitment_id, // Private: Commitment ID\n        merkle_path, // Private: Merkle path\n        merkle_indices, // Private: Merkle indices\n    );\n}\n\n#[test(should_fail)]\nfn test_zero_value_transfer() {\n    // This test SHOULD FAIL because we require positive transfer amounts\n\n    let value_alice_old = 100;\n    let value_alice_new = 100; // Alice keeps everything\n    let value_bob_received = 0; // Bob gets nothing - this should fail\n\n    let nonce_alice_old = 111;\n    let nonce_alice_new = 222;\n    let nonce_bob = 333; // Bob's secret nonce\n    let alice_secret_key = 12345;\n    let asset_id = 1;\n    let alice_old_commitment_id = 999;\n\n    // Setup Merkle tree with Alice's commitment\n    let alice_old_commitment = Commitment::new(value_alice_old, nonce_alice_old, asset_id);\n    let merkle_root = alice_old_commitment.hash;\n    let merkle_path: [Field; 20] = [0; 20];\n    let merkle_indices: [bool; 20] = [false; 20];\n\n    let alice_new_commitment = Commitment::new(value_alice_new, nonce_alice_new, asset_id);\n    let bob_commitment = Commitment::new(value_bob_received, nonce_bob, asset_id);\n    let nullifier = Nullifier::new(alice_secret_key, alice_old_commitment_id);\n\n    // This will fail the positive value check: assert(value_bob_received as u32 > 0)\n    main(\n        merkle_root, // Public: Tree root\n        nullifier.hash, // Public: Nullifier\n        alice_new_commitment.hash, // Public: Alice's new commitment\n        bob_commitment.hash, // Public: Bob's commitment\n        asset_id, // Public: Asset ID\n        value_alice_old, // Private: Alice's old balance\n        value_alice_new, // Private: Alice's new balance\n        value_bob_received, // Private: Transfer amount (0 - should fail!)\n        nonce_alice_old, // Private: Old nonce\n        nonce_alice_new, // Private: New nonce\n        alice_secret_key, // Private: Secret key\n        alice_old_commitment_id, // Private: Commitment ID\n        merkle_path, // Private: Merkle path\n        merkle_indices, // Private: Merkle indices\n    );\n}\n","path":"/Users/abuusama/Desktop/private-starknet/circuits/commitment_system/src/main.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_invert","directive_integer_quotient"]}